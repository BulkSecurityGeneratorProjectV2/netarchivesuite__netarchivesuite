Only in datamodel: H1HeritrixTemplate.java
Only in datamodel: H3HeritrixTemplate.java
diff -ur datamodel/HeritrixTemplate.java datamodel.newest/HeritrixTemplate.java
--- datamodel/HeritrixTemplate.java	2014-10-22 16:55:11.458275712 +0200
+++ datamodel.newest/HeritrixTemplate.java	2014-10-22 17:40:19.491110467 +0200
@@ -1,84 +1,373 @@
+/*
+ * #%L
+ * Netarchivesuite - harvester
+ * %%
+ * Copyright (C) 2005 - 2014 The Royal Danish Library, the Danish State and University Library,
+ *             the National Library of France and the Austrian National Library.
+ * %%
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation, either version 2.1 of the
+ * License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Lesser Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Lesser Public
+ * License along with this program.  If not, see
+ * <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ * #L%
+ */
 package dk.netarkivet.harvester.datamodel;
 
-import java.io.File;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.io.Reader;
-import java.sql.Clob;
-import java.sql.SQLException;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import org.archive.crawler.deciderules.DecidingScope;
+import org.archive.crawler.deciderules.MatchesListRegExpDecideRule;
+import org.dom4j.Document;
+import org.dom4j.Element;
+import org.dom4j.Node;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import dk.netarkivet.common.exceptions.ArgumentNotValid;
 import dk.netarkivet.common.exceptions.IOFailure;
 import dk.netarkivet.common.exceptions.IllegalState;
+import dk.netarkivet.common.exceptions.PermissionDenied;
+import dk.netarkivet.common.utils.Settings;
+import dk.netarkivet.common.utils.XmlUtils;
+import dk.netarkivet.harvester.HarvesterSettings;
 import dk.netarkivet.harvester.harvesting.HeritrixFiles;
 
-public abstract class HeritrixTemplate {
+/**
+ * Class encapsulating the Heritrix order.xml. Enables verification that dom4j Document obey the constraints required by
+ * our software, specifically the Job class.
+ * <p>
+ * The class assumes the type of order.xml used in configuring Heritrix version 1.10+. Information about the Heritrix
+ * crawler, and its processes and modules can be found in the Heritrix developer and user manuals found on <a
+ * href="http://crawler.archive.org">http://crawler.archive.org<a/>
+ */
+public class HeritrixTemplate {
 
-	private static final CharSequence H1_SIGNATURE = "<crawl-order xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance"; 
-	private static final CharSequence H3_SIGNATURE = "xmlns:\"http://www.springframework.org/";
-	public abstract boolean isValid();
-	public abstract String getXML();
-
-	/** insertion-methods 
-	 * 
-	 * Two methods for adding domain quotas to the quotaEnforcer bean.
-	 * maxBytesPerDomain()
-	 * maxObjectsPerDomain()
-	 * 
-	 * One or two methods for inserting crawlertraps
-	 * insertGlobalCrawlerTraps
-	 * insertDomainSpecificCrawlerTraps 
-     */	
-	
-	 /**
-     * Activates or deactivate the quota-enforcer, depending on budget definition. Object limit can be defined either by
-     * using the queue-total-budget property or the quota enforcer. Which is chosen is set by the argument
-     * maxObjectsIsSetByQuotaEnforcer}'s value. So quota enforcer is set as follows:
-     * <ul>
-     * <li>Object limit is not set by quota enforcer, disabled only if there is no byte limit.</li>
-     * <li>Object limit is set by quota enforcer, so it should be enabled whether a byte or object limit is set.</li>
-     * </ul>
+    private static final Logger log = LoggerFactory.getLogger(HeritrixTemplate.class);
+
+    /** the dom4j Document hiding behind this instance of HeritrixTemplate. */
+    private Document template;
+
+    /** has this HeritrixTemplate been verified. */
+    private boolean verified;
+
+    /** Xpath needed by Job.editOrderXML_maxBytesPerDomain(). */
+    public static final String QUOTA_ENFORCER_ENABLED_XPATH = "/crawl-order/controller/map[@name='pre-fetch-processors']"
+            + "/newObject[@name='QuotaEnforcer']" + "/boolean[@name='enabled']";;
+    /** Xpath needed by Job.editOrderXML_maxBytesPerDomain(). */
+    public static final String GROUP_MAX_ALL_KB_XPATH = "/crawl-order/controller/map[@name='pre-fetch-processors']"
+            + "/newObject[@name='QuotaEnforcer']" + "/long[@name='group-max-all-kb']";
+    /** Xpath needed by Job.editOrderXML_maxObjectsPerDomain(). */
+    public static final String GROUP_MAX_FETCH_SUCCESS_XPATH = "/crawl-order/controller/map[@name='pre-fetch-processors']"
+            + "/newObject[@name='QuotaEnforcer']" + "/long[@name='group-max-fetch-successes']";
+    /** Xpath needed by Job.editOrderXML_maxObjectsPerDomain(). */
+    public static final String QUEUE_TOTAL_BUDGET_XPATH = "/crawl-order/controller/newObject[@name='frontier']"
+            + "/long[@name='queue-total-budget']";
+    /** Xpath needed by Job.editOrderXML_crawlerTraps(). */
+    public static final String DECIDERULES_MAP_XPATH = "/crawl-order/controller/newObject"
+            + "/newObject[@name='decide-rules']" + "/map[@name='rules']";
+    /** Xpath needed by Job.editOrderXML_crawlerTraps(). */
+    public static final String DECIDERULES_ACCEPT_IF_PREREQUISITE_XPATH = "/crawl-order/controller/newObject"
+            + "/newObject[@name='decide-rules']" + "/map[@name='rules']/newObject[@class="
+            + "'org.archive.crawler.deciderules.PrerequisiteAcceptDecideRule']";
+
+    /** Xpath checked by Heritrix for correct user-agent field in requests. */
+    public static final String HERITRIX_USER_AGENT_XPATH = "/crawl-order/controller/map[@name='http-headers']"
+            + "/string[@name='user-agent']";
+    /** Xpath checked by Heritrix for correct mail address. */
+    public static final String HERITRIX_FROM_XPATH = "/crawl-order/controller/map[@name='http-headers']/"
+            + "string[@name='from']";
+    /** Xpath to check, that all templates use the DecidingScope. */
+    public static final String DECIDINGSCOPE_XPATH = "/crawl-order/controller/newObject[@name='scope']" + "[@class='"
+            + DecidingScope.class.getName() + "']";
+    /**
+     * Xpath for the deduplicator node in order.xml documents.
+     */
+    public static final String DEDUPLICATOR_XPATH = "/crawl-order/controller/map[@name='write-processors']"
+            + "/newObject[@name='DeDuplicator']";
+
+    /**
+     * Xpath to check, that all templates use the same ARC archiver path,
+     * {@link dk.netarkivet.common.Constants#ARCDIRECTORY_NAME}. The archive path tells Heritrix to which directory it
+     * shall write its arc files.
+     */
+    public static final String ARC_ARCHIVER_PATH_XPATH = "/crawl-order/controller/map[@name='write-processors']/"
+            + "newObject[@name='Archiver']/stringList[@name='path']/string";
+
+    /**
+     * Xpath to check, that all templates use the same WARC archiver path,
+     * {@link dk.netarkivet.common.Constants#WARCDIRECTORY_NAME}. The archive path tells Heritrix to which directory it
+     * shall write its arc files.
+     */
+    public static final String WARC_ARCHIVER_PATH_XPATH = "/crawl-order/controller/map[@name='write-processors']/"
+            + "newObject[@name='WARCArchiver']/stringList[@name='path']/string";
+
+    /**
+     * Xpath for the deduplicator index directory node in order.xml documents.
+     */
+    public static final String DEDUPLICATOR_INDEX_LOCATION_XPATH = HeritrixTemplate.DEDUPLICATOR_XPATH
+            + "/string[@name='index-location']";
+
+    /**
+     * Xpath for the boolean telling if the deduplicator is enabled in order.xml documents.
+     */
+    public static final String DEDUPLICATOR_ENABLED = HeritrixTemplate.DEDUPLICATOR_XPATH + "/boolean[@name='enabled']";
+
+    /** Xpath for the 'disk-path' in the order.xml . */
+    public static final String DISK_PATH_XPATH = "//crawl-order/controller" + "/string[@name='disk-path']";
+    /** Xpath for the arcfile 'prefix' in the order.xml . */
+    public static final String ARCHIVEFILE_PREFIX_XPATH = "//crawl-order/controller" + "/map[@name='write-processors']"
+            + "/newObject/string[@name='prefix']";
+    /** Xpath for the ARCs dir in the order.xml. */
+    public static final String ARCSDIR_XPATH = "//crawl-order/controller" + "/map[@name='write-processors']"
+            + "/newObject[@name='Archiver']/stringList[@name='path']/string";
+
+    private static final String WARCWRITERPROCESSOR_XPATH = "//crawl-order/controller"
+            + "/map[@name='write-processors']" + "/newObject[@name='WARCArchiver']";
+
+    private static final String ARCWRITERPROCESSOR_XPATH = "//crawl-order/controller"
+            + "/map[@name='write-processors']" + "/newObject[@name='Archiver']";
+
+    /** Xpath for the WARCs dir in the order.xml. */
+    public static final String WARCSDIR_XPATH = WARCWRITERPROCESSOR_XPATH + "/stringList[@name='path']/string";
+
+    /** Xpath for the 'seedsfile' in the order.xml. */
+    public static final String SEEDS_FILE_XPATH = "//crawl-order/controller" + "/newObject[@name='scope']"
+            + "/string[@name='seedsfile']";
+
+    public static final String ARCS_ENABLED_XPATH = ARCWRITERPROCESSOR_XPATH + "/boolean[@name='enabled']";
+
+    /** Xpath for the WARCs dir in the order.xml. */
+    public static final String WARCS_ENABLED_XPATH = WARCWRITERPROCESSOR_XPATH + "/boolean[@name='enabled']";
+
+    public static final String WARCS_WRITE_REQUESTS_XPATH = WARCWRITERPROCESSOR_XPATH
+            + "/boolean[@name='write-requests']";
+    public static final String WARCS_WRITE_METADATA_XPATH = WARCWRITERPROCESSOR_XPATH
+            + "/boolean[@name='write-metadata']";
+    public static final String WARCS_SKIP_IDENTICAL_DIGESTS_XPATH = WARCWRITERPROCESSOR_XPATH
+            + "/boolean[@name='skip-identical-digests']";
+    public static final String WARCS_WRITE_REVISIT_FOR_IDENTICAL_DIGESTS_XPATH = WARCWRITERPROCESSOR_XPATH
+            + "/boolean[@name='write-revisit-for-identical-digests']";
+    public static final String WARCS_WRITE_REVISIT_FOR_NOT_MODIFIED_XPATH = WARCWRITERPROCESSOR_XPATH
+            + "/boolean[@name='write-revisit-for-not-modified']";
+
+    /**
+     * Map from required xpaths to a regular expression describing legal content for the path text.
+     */
+    private static final Map<String, Pattern> requiredXpaths = new HashMap<String, Pattern>();
+
+    /**
+     * A regular expression that matches a whole number, possibly negative, and with optional whitespace around it.
+     */
+    private static final String WHOLE_NUMBER_REGEXP = "\\s*-?[0-9]+\\s*";
+    /**
+     * A regular expression that matches everything. Except newlines, unless DOTALL is given to Pattern.compile().
+     */
+    private static final String EVERYTHING_REGEXP = ".*";
+
+    // These two regexps are copied from
+    // org.archive.crawler.datamodel.CrawlOrder because they're private there.
+
+    /**
+     * A regular expression that matches Heritrix' specs for the user-agent field in order.xml. It should be used with
+     * DOTALL. An example match is "Org (ourCrawler, see +http://org.org/aPage for details) harvest".
+     */
+    private static final String USER_AGENT_REGEXP = "\\S+.*\\(.*\\+http(s)?://\\S+\\.\\S+.*\\).*";
+    /**
+     * A regular expression that matches Heritrix' specs for the from field. This should be a valid email address.
+     */
+    private static final String FROM_REGEXP = "\\S+@\\S+\\.\\S+";
+
+    /**
+     * Xpath to check, that all templates have the max-time-sec attribute.
+     */
+    public static final String MAXTIMESEC_PATH_XPATH = "/crawl-order/controller/long[@name='max-time-sec']";
+
+    static {
+        requiredXpaths.put(GROUP_MAX_FETCH_SUCCESS_XPATH, Pattern.compile(WHOLE_NUMBER_REGEXP));
+        requiredXpaths.put(QUEUE_TOTAL_BUDGET_XPATH, Pattern.compile(WHOLE_NUMBER_REGEXP));
+        requiredXpaths.put(GROUP_MAX_ALL_KB_XPATH, Pattern.compile(WHOLE_NUMBER_REGEXP));
+
+        // Required that we use DecidingScope
+        // requiredXpaths.put(DECIDINGSCOPE_XPATH,
+        // Pattern.compile(EVERYTHING_REGEXP));
+
+        // Required that we have a rules map used to add crawlertraps
+        requiredXpaths.put(DECIDERULES_MAP_XPATH, Pattern.compile(EVERYTHING_REGEXP, Pattern.DOTALL));
+
+        requiredXpaths.put(HERITRIX_USER_AGENT_XPATH, Pattern.compile(USER_AGENT_REGEXP, Pattern.DOTALL));
+        requiredXpaths.put(HERITRIX_FROM_XPATH, Pattern.compile(FROM_REGEXP));
+
+        // max-time-sec attribute needed, so we can't override it set
+        // a timelimit on broad crawls.
+        requiredXpaths.put(MAXTIMESEC_PATH_XPATH, Pattern.compile(WHOLE_NUMBER_REGEXP));
+    }
+
+    /**
+     * Constructor for HeritrixTemplate class.
      *
-     * @param maxObjectsIsSetByQuotaEnforcer Decides whether the maxObjectsIsSetByQuotaEnforcer or not.
-     * @param forceMaxBytesPerDomain The number of max bytes per domain enforced (can be no limit)
-     * @param forceMaxObjectsPerDomain The number of max objects per domain enforced (can be no limit)
+     * @param doc the order.xml
+     * @param verify If true, verifies if the given dom4j Document contains the elements required by our software.
+     * @throws ArgumentNotValid if doc is null, or verify is true and doc does not obey the constraints required by our
+     * software.
+     */
+    public HeritrixTemplate(Document doc, boolean verify) {
+        ArgumentNotValid.checkNotNull(doc, "Document doc");
+        String xpath;
+        Node node;
+        Pattern pattern;
+        Matcher matcher;
+        if (verify) {
+            for (Map.Entry<String, Pattern> required : requiredXpaths.entrySet()) {
+                xpath = required.getKey();
+                node = doc.selectSingleNode(xpath);
+                ArgumentNotValid.checkTrue(node != null, "Template error: Missing node: " + xpath);
+
+                pattern = required.getValue();
+                matcher = pattern.matcher(node.getText().trim());
+
+                ArgumentNotValid.checkTrue(matcher.matches(), "Template error: Value '" + node.getText()
+                        + "' of node '" + xpath + "' does not match required regexp '" + pattern + "'");
+            }
+            verified = true;
+            // Required that Heritrix write its ARC/WARC files to the correct dir
+            // relative to the crawldir. This dir is defined by the constant:
+            // dk.netarkivet.common.Constants.ARCDIRECTORY_NAME.
+            // dk.netarkivet.common.Constants.WARCDIRECTORY_NAME.
+            int validArchivePaths = 0;
+            node = doc.selectSingleNode(ARC_ARCHIVER_PATH_XPATH);
+            if (node != null) {
+                pattern = Pattern.compile(dk.netarkivet.common.Constants.ARCDIRECTORY_NAME);
+                matcher = pattern.matcher(node.getText().trim());
+                ArgumentNotValid.checkTrue(matcher.matches(), "Template error: Value '" + node.getText()
+                        + "' of node '" + ARC_ARCHIVER_PATH_XPATH + "' does not match required regexp '" + pattern
+                        + "'");
+                ++validArchivePaths;
+            }
+            node = doc.selectSingleNode(WARC_ARCHIVER_PATH_XPATH);
+            if (node != null) {
+                pattern = Pattern.compile(dk.netarkivet.common.Constants.WARCDIRECTORY_NAME);
+                matcher = pattern.matcher(node.getText().trim());
+                ArgumentNotValid.checkTrue(matcher.matches(), "Template error: Value '" + node.getText()
+                        + "' of node '" + WARC_ARCHIVER_PATH_XPATH + "' does not match required regexp '" + pattern
+                        + "'");
+                ++validArchivePaths;
+            }
+            ArgumentNotValid.checkTrue(validArchivePaths > 0, "Template error: "
+                    + "An ARC or WARC writer processor seems to be missing");
+        }
+        this.template = (Document) doc.clone();
+    }
+
+    /**
+     * Alternate constructor, which always verifies the given document.
+     *
+     * @param doc
+     */
+    public HeritrixTemplate(Document doc) {
+        this(doc, true);
+    }
+
+    /**
+     * return the template.
+     *
+     * @return the template
+     */
+    public Document getTemplate() {
+        return (Document) template.clone();
+    }
+
+    /**
+     * Has Template been verified?
+     *
+     * @return true, if verified on construction, otherwise false
      */
-	public abstract void configureQuotaEnforcer(
-			boolean maxObjectsIsSetByQuotaEnforcer, long forceMaxBytesPerDomain, long forceMaxObjectsPerDomain);
-	
-	public abstract void setMaxBytesPerDomain(Long maxbytesL);
-	public abstract Long getMaxBytesPerDomain(); // TODO Is necessary? 
-	
-	public abstract void setMaxObjectsPerDomain(Long maxobjectsL);
-	public abstract Long getMaxObjectsPerDomain(); // TODO Is necessary? 
-	
-	public abstract boolean IsDeduplicationEnabled();
-	
-	
-	
-	/**
+    public boolean isVerified() {
+        return verified;
+    }
+
+    /**
+     * Return HeritrixTemplate as XML.
+     *
+     * @return HeritrixTemplate as XML
+     */
+    public String getXML() {
+        return template.asXML();
+    }
+
+    /**
      * Method to add a list of crawler traps with a given element name. It is used both to add per-domain traps and
      * global traps.
      *
      * @param elementName The name of the added element.
      * @param crawlerTraps A list of crawler trap regular expressions to add to this job.
      */
+    @SuppressWarnings("unchecked")
+    public static void editOrderXMLAddCrawlerTraps(Document orderXMLdoc, String elementName, List<String> crawlerTraps) {
+        if (crawlerTraps.size() == 0) {
+            return;
+        }
 
-	public abstract void insertCrawlerTraps(String elementName, List<String> crawlertraps);
-	
-	/**
-     * Make sure that Heritrix will archive its data in the chosen archiveFormat.
-     *
-     * @param archiveFormat the chosen archiveformat ('arc' or 'warc' supported) Throws ArgumentNotValid If the chosen
-     * archiveFormat is not supported.
-     */
-	public abstract void setArchiveFormat(String archiveFormat);
-	
-	
-	public abstract void setMaxJobRunningTime(Long maxJobRunningTimeSecondsL);
-	
-	/**
+        // Get the node to update
+        // If there is an acceptIfPrerequisite decideRule in the template, crawler traps should be
+        // placed before (cf. issue NAS-2205)
+        // If no such rule exists then we append the crawler traps as to the existing decideRuleds.
+
+        Node rulesMapNode = orderXMLdoc.selectSingleNode(HeritrixTemplate.DECIDERULES_MAP_XPATH);
+        if (rulesMapNode == null || !(rulesMapNode instanceof Element)) {
+            throw new IllegalState("Unable to update order.xml document. It does not have the right form to add"
+                    + "crawler trap deciderules.");
+        }
+
+        Element rulesMap = (Element) rulesMapNode;
+
+        // Create the root node and append it top existing rules
+        Element decideRule = rulesMap.addElement("newObject");
+
+        // If an acceptiIfPrerequisite node exists, detach and insert before it
+        Node acceptIfPrerequisiteNode = orderXMLdoc
+                .selectSingleNode(HeritrixTemplate.DECIDERULES_ACCEPT_IF_PREREQUISITE_XPATH);
+        if (acceptIfPrerequisiteNode != null) {
+            List<Node> elements = rulesMap.elements();
+            int insertPosition = elements.indexOf(acceptIfPrerequisiteNode);
+            decideRule.detach();
+            elements.add(insertPosition, decideRule);
+        } else {
+            rulesMap.elements().size();
+        }
+
+        // Add all regexps in the list to a single MatchesListRegExpDecideRule
+        decideRule.addAttribute("name", elementName);
+        decideRule.addAttribute("class", MatchesListRegExpDecideRule.class.getName());
+
+        Element decision = decideRule.addElement("string");
+        decision.addAttribute("name", "decision");
+        decision.addText("REJECT");
+
+        Element listlogic = decideRule.addElement("string");
+        listlogic.addAttribute("name", "list-logic");
+        listlogic.addText("OR");
+
+        Element regexpList = decideRule.addElement("stringList");
+        regexpList.addAttribute("name", "regexp-list");
+        for (String trap : crawlerTraps) {
+            regexpList.addElement("string").addText(trap);
+        }
+    }
+
+    /**
      * Updates the order.xml to include a MatchesListRegExpDecideRule for each crawlertrap associated with for the given
      * DomainConfiguration.
      * <p>
@@ -91,19 +380,226 @@
      * @param cfg The DomainConfiguration for which to generate crawler trap deciderules
      * @throws IllegalState If unable to update order.xml due to wrong order.xml format
      */
-    public void editOrderXMLAddPerDomainCrawlerTraps(DomainConfiguration cfg) {
+    public static void editOrderXMLAddPerDomainCrawlerTraps(Document orderXmlDoc, DomainConfiguration cfg) {
+        // Get the regexps to exclude
         List<String> crawlerTraps = cfg.getCrawlertraps();
         String elementName = cfg.getDomainName();
-        insertCrawlerTraps(elementName, crawlerTraps);
+        HeritrixTemplate.editOrderXMLAddCrawlerTraps(orderXmlDoc, elementName, crawlerTraps);
     }
-    
+
     /**
-     * 
-     * Updates the diskpath value, archivefile_prefix, seedsfile, and deduplication -information.
-     * FIXME HeritrixFiles could be different from H1 and H. Consider making this an abstract class as well.
-     * @param files
-     * @throws IOFailure
+     * Make sure that Heritrix will archive its data in the chosen archiveFormat.
+     *
+     * @param orderXML the specific heritrix template to modify.
+     * @param archiveFormat the chosen archiveformat ('arc' or 'warc' supported) Throws ArgumentNotValid If the chosen
+     * archiveFormat is not supported.
+     */
+    public static void editOrderXML_ArchiveFormat(Document orderXML, String archiveFormat) {
+        boolean arcMode = false;
+        boolean warcMode = false;
+
+        if ("arc".equalsIgnoreCase(archiveFormat)) {
+            arcMode = true;
+            log.debug("ARC format selected to be used by Heritrix");
+        } else if ("warc".equalsIgnoreCase(archiveFormat)) {
+            warcMode = true;
+            log.debug("WARC format selected to be used by Heritrix");
+        } else {
+            throw new ArgumentNotValid("Configuration of '" + HarvesterSettings.HERITRIX_ARCHIVE_FORMAT
+                    + "' is invalid! Unrecognized format '" + archiveFormat + "'.");
+        }
+
+        if (arcMode) {
+            // enable ARC writing in Heritrix and disable WARC writing if needed.
+            if (orderXML.selectSingleNode(HeritrixTemplate.ARCSDIR_XPATH) != null
+                    && orderXML.selectSingleNode(HeritrixTemplate.ARCS_ENABLED_XPATH) != null) {
+                XmlUtils.setNode(orderXML, HeritrixTemplate.ARCSDIR_XPATH,
+                        dk.netarkivet.common.Constants.ARCDIRECTORY_NAME);
+                XmlUtils.setNode(orderXML, HeritrixTemplate.ARCS_ENABLED_XPATH, "true");
+                if (orderXML.selectSingleNode(HeritrixTemplate.WARCS_ENABLED_XPATH) != null) {
+                    XmlUtils.setNode(orderXML, HeritrixTemplate.WARCS_ENABLED_XPATH, "false");
+                }
+            } else {
+                throw new IllegalState("Unable to choose ARC as Heritrix archive format because "
+                        + " one of the following xpaths are invalid in the given order.xml: "
+                        + HeritrixTemplate.ARCSDIR_XPATH + "," + HeritrixTemplate.ARCS_ENABLED_XPATH);
+            }
+        } else if (warcMode) { // WARCmode
+            // enable ARC writing in Heritrix and disable WARC writing if needed.
+            if (orderXML.selectSingleNode(HeritrixTemplate.WARCSDIR_XPATH) != null
+                    && orderXML.selectSingleNode(HeritrixTemplate.WARCS_ENABLED_XPATH) != null) {
+                XmlUtils.setNode(orderXML, HeritrixTemplate.WARCSDIR_XPATH,
+                        dk.netarkivet.common.Constants.WARCDIRECTORY_NAME);
+                XmlUtils.setNode(orderXML, HeritrixTemplate.WARCS_ENABLED_XPATH, "true");
+                if (orderXML.selectSingleNode(HeritrixTemplate.ARCS_ENABLED_XPATH) != null) {
+                    XmlUtils.setNode(orderXML, HeritrixTemplate.ARCS_ENABLED_XPATH, "false");
+                }
+
+                // Update the WARCWriterProcessorSettings with settings values
+                setIfFound(orderXML, HeritrixTemplate.WARCS_SKIP_IDENTICAL_DIGESTS_XPATH,
+                        HarvesterSettings.HERITRIX_WARC_SKIP_IDENTICAL_DIGESTS,
+                        Settings.get(HarvesterSettings.HERITRIX_WARC_SKIP_IDENTICAL_DIGESTS));
+
+                setIfFound(orderXML, HeritrixTemplate.WARCS_WRITE_METADATA_XPATH,
+                        HarvesterSettings.HERITRIX_WARC_WRITE_METADATA,
+                        Settings.get(HarvesterSettings.HERITRIX_WARC_WRITE_METADATA));
+
+                setIfFound(orderXML, HeritrixTemplate.WARCS_WRITE_REQUESTS_XPATH,
+                        HarvesterSettings.HERITRIX_WARC_WRITE_REQUESTS,
+                        Settings.get(HarvesterSettings.HERITRIX_WARC_WRITE_REQUESTS));
+
+                setIfFound(orderXML, HeritrixTemplate.WARCS_WRITE_REVISIT_FOR_IDENTICAL_DIGESTS_XPATH,
+                        HarvesterSettings.HERITRIX_WARC_WRITE_REVISIT_FOR_IDENTICAL_DIGESTS,
+                        Settings.get(HarvesterSettings.HERITRIX_WARC_WRITE_REVISIT_FOR_IDENTICAL_DIGESTS));
+                setIfFound(orderXML, HeritrixTemplate.WARCS_WRITE_REVISIT_FOR_NOT_MODIFIED_XPATH,
+                        HarvesterSettings.HERITRIX_WARC_WRITE_REVISIT_FOR_NOT_MODIFIED,
+                        Settings.get(HarvesterSettings.HERITRIX_WARC_WRITE_REVISIT_FOR_NOT_MODIFIED));
+
+            } else {
+                throw new IllegalState("Unable to choose WARC as Heritrix archive format because "
+                        + " one of the following xpaths are invalid in the given order.xml: "
+                        + HeritrixTemplate.WARCSDIR_XPATH + "," + HeritrixTemplate.WARCS_ENABLED_XPATH
+                        + ". order.xml: " + orderXML.asXML());
+            }
+
+        } else {
+            throw new IllegalState("Unknown state: "
+                    + "Should have selected either ARC or WARC as heritrix archive format");
+        }
+    }
+
+    private static void setIfFound(Document doc, String Xpath, String param, String value) {
+        if (doc.selectSingleNode(Xpath) != null) {
+            XmlUtils.setNode(doc, Xpath, value);
+        } else {
+            log.warn("Could not replace setting value of '" + param + "' in template. Xpath not found: " + Xpath);
+        }
+    }
+
+    /**
+     * @param maxJobRunningTime Force the harvestjob to end after maxJobRunningTime
      */
+    public static void editOrderXML_maxJobRunningTime(Document orderXMLdoc, long maxJobRunningTime) {
+        // get and set the "max-time-sec" node of the orderXMLdoc
+        String xpath = HeritrixTemplate.MAXTIMESEC_PATH_XPATH;
+        Node groupMaxTimeSecNode = orderXMLdoc.selectSingleNode(xpath);
+        if (groupMaxTimeSecNode != null) {
+            String currentMaxTimeSec = groupMaxTimeSecNode.getText();
+            groupMaxTimeSecNode.setText(Long.toString(maxJobRunningTime));
+            log.trace("Value of groupMaxTimeSecNode changed from " + currentMaxTimeSec + " to " + maxJobRunningTime);
+        } else {
+            throw new IOFailure("Unable to locate xpath '" + xpath + "' in the order.xml: " + orderXMLdoc.asXML());
+        }
+    }
+
+    /**
+     * Auxiliary method to modify the orderXMLdoc Document with respect to setting the maximum number of objects to be
+     * retrieved per domain. This method updates 'group-max-fetch-success' element of the QuotaEnforcer pre-fetch
+     * processor node (org.archive.crawler.frontier.BdbFrontier) with the value of the argument forceMaxObjectsPerDomain
+     *
+     * @param orderXMLdoc
+     * @param forceMaxObjectsPerDomain The maximum number of objects to retrieve per domain, or 0 for no limit.
+     * @throws PermissionDenied If unable to replace the frontier node of the orderXMLdoc Document
+     * @throws IOFailure If the group-max-fetch-success element is not found in the orderXml. TODO The
+     * group-max-fetch-success check should also be performed in TemplateDAO.create, TemplateDAO.update
+     */
+    public static void editOrderXML_maxObjectsPerDomain(Document orderXMLdoc, long forceMaxObjectsPerDomain,
+            boolean maxObjectsIsSetByQuotaEnforcer) {
+
+        String xpath = (maxObjectsIsSetByQuotaEnforcer ? HeritrixTemplate.GROUP_MAX_FETCH_SUCCESS_XPATH
+                : HeritrixTemplate.QUEUE_TOTAL_BUDGET_XPATH);
+
+        Node orderXmlNode = orderXMLdoc.selectSingleNode(xpath);
+        if (orderXmlNode != null) {
+            orderXmlNode.setText(String.valueOf(forceMaxObjectsPerDomain));
+        } else {
+            throw new IOFailure("Unable to locate " + xpath + " element in order.xml: " + orderXMLdoc.asXML());
+        }
+    }
+
+    /**
+     * Activates or deactivate the quota-enforcer, depending on budget definition. Object limit can be defined either by
+     * using the queue-total-budget property or the quota enforcer. Which is chosen is set by the argument
+     * maxObjectsIsSetByQuotaEnforcer}'s value. So quota enforcer is set as follows:
+     * <ul>
+     * <li>Object limit is not set by quota enforcer, disabled only if there is no byte limit.</li>
+     * <li>Object limit is set by quota enforcer, so it should be enabled whether a byte or object limit is set.</li>
+     * </ul>
+     *
+     * @param orderXMLdoc the template to modify
+     * @param maxObjectsIsSetByQuotaEnforcer Decides whether the maxObjectsIsSetByQuotaEnforcer or not.
+     * @param forceMaxBytesPerDomain The number of max bytes per domain enforced (can be no limit)
+     * @param forceMaxObjectsPerDomain The number of max objects per domain enforced (can be no limit)
+     */
+    public static void editOrderXML_configureQuotaEnforcer(Document orderXMLdoc,
+            boolean maxObjectsIsSetByQuotaEnforcer, long forceMaxBytesPerDomain, long forceMaxObjectsPerDomain) {
+
+        boolean quotaEnabled = true;
+
+        if (!maxObjectsIsSetByQuotaEnforcer) {
+            // Object limit is not set by quota enforcer, so it should be disabled only
+            // if there is no byte limit.
+            quotaEnabled = forceMaxBytesPerDomain != Constants.HERITRIX_MAXBYTES_INFINITY;
+
+        } else {
+            // Object limit is set by quota enforcer, so it should be enabled whether
+            // a byte or object limit is set.
+            quotaEnabled = forceMaxObjectsPerDomain != Constants.HERITRIX_MAXOBJECTS_INFINITY
+                    || forceMaxBytesPerDomain != Constants.HERITRIX_MAXBYTES_INFINITY;
+        }
+
+        String xpath = HeritrixTemplate.QUOTA_ENFORCER_ENABLED_XPATH;
+        Node qeNode = orderXMLdoc.selectSingleNode(xpath);
+        if (qeNode != null) {
+            qeNode.setText(Boolean.toString(quotaEnabled));
+        } else {
+            throw new IOFailure("Unable to locate " + xpath + " element in order.xml: " + orderXMLdoc.asXML());
+        }
+    }
+
+    /**
+     * Auxiliary method to modify the orderXMLdoc Document with respect to setting the maximum number of bytes to
+     * retrieve per domain. This method updates 'group-max-all-kb' element of the 'QuotaEnforcer' node, which again is a
+     * subelement of 'pre-fetch-processors' node. with the value of the argument forceMaxBytesPerDomain
+     *
+     * @param forceMaxBytesPerDomain The maximum number of byte to retrieve per domain, or -1 for no limit. Note that
+     * the number is divided by 1024 before being inserted into the orderXml, as Heritrix expects KB.
+     * @throws PermissionDenied If unable to replace the QuotaEnforcer node of the orderXMLdoc Document
+     * @throws IOFailure If the group-max-all-kb element cannot be found. TODO This group-max-all-kb check also be
+     * performed in TemplateDAO.create, TemplateDAO.update
+     */
+    public static void editOrderXML_maxBytesPerDomain(Document orderXMLdoc, long forceMaxBytesPerDomain) {
+        // get and set the group-max-all-kb Node of the orderXMLdoc:
+        String xpath = HeritrixTemplate.GROUP_MAX_ALL_KB_XPATH;
+        Node groupMaxSuccessKbNode = orderXMLdoc.selectSingleNode(xpath);
+        if (groupMaxSuccessKbNode != null) {
+            if (forceMaxBytesPerDomain == 0) {
+                groupMaxSuccessKbNode.setText("0");
+            } else if (forceMaxBytesPerDomain != Constants.HERITRIX_MAXBYTES_INFINITY) {
+                // Divide by 1024 since Heritrix uses KB rather than bytes,
+                // and add 1 to avoid to low limit due to rounding.
+                groupMaxSuccessKbNode.setText(Long
+                        .toString((forceMaxBytesPerDomain / Constants.BYTES_PER_HERITRIX_BYTELIMIT_UNIT) + 1));
+            } else {
+                groupMaxSuccessKbNode.setText(String.valueOf(Constants.HERITRIX_MAXBYTES_INFINITY));
+            }
+        } else {
+            throw new IOFailure("Unable to locate QuotaEnforcer object in order.xml: " + orderXMLdoc.asXML());
+        }
+    }
+
+    /**
+     * Return true if the given order.xml file has deduplication enabled.
+     *
+     * @param doc An order.xml document
+     * @return True if Deduplicator is enabled.
+     */
+    public static boolean isDeduplicationEnabledInTemplate(Document doc) {
+        ArgumentNotValid.checkNotNull(doc, "Document doc");
+        Node xpathNode = doc.selectSingleNode(HeritrixTemplate.DEDUPLICATOR_ENABLED);
+        return xpathNode != null && xpathNode.getText().trim().equals("true");
+    }
+
     /**
      * This method prepares the orderfile used by the Heritrix crawler. </p> 1. alters the orderfile in the
      * following-way: (overriding whatever is in the orderfile)</br>
@@ -120,104 +616,23 @@
      * 3. if deduplication is enabled in the order.xml, it writes the absolute path of the lucene index used by the
      * deduplication processor.
      *
-     * @throws IOFailure - When the orderfile could not be saved to disk 
-     *                     When a specific element cannot be found in the document. 
+     * @throws IOFailure - When the orderfile could not be saved to disk When a specific node is not found in the
+     * XML-document When the SAXReader cannot parse the XML
      */
-        
-    
-    public static void makeTemplateReadyForHeritrix(HeritrixFiles files) throws IOFailure {
-    	HeritrixTemplate templ = HeritrixTemplate.read(files.getOrderXmlFile());
-    	templ.setDiskPath(files.getCrawlDir().getAbsolutePath());
-    	templ.setArchiveFilePrefix(files.getArchiveFilePrefix());
-    	templ.setSeedsFilePath(files.getSeedsTxtFile().getAbsolutePath());
-        if (templ.IsDeduplicationEnabled()) {
-        	templ.setDeduplicationIndexLocation(files.getIndexDir()
+    public static void makeOrderfileReadyForHeritrix(HeritrixFiles files) throws IOFailure {
+        Document doc = XmlUtils.getXmlDoc(files.getOrderXmlFile());
+        XmlUtils.setNode(doc, HeritrixTemplate.DISK_PATH_XPATH, files.getCrawlDir().getAbsolutePath());
+
+        XmlUtils.setNodes(doc, HeritrixTemplate.ARCHIVEFILE_PREFIX_XPATH, files.getArchiveFilePrefix());
+
+        XmlUtils.setNode(doc, HeritrixTemplate.SEEDS_FILE_XPATH, files.getSeedsTxtFile().getAbsolutePath());
+
+        if (isDeduplicationEnabledInTemplate(doc)) {
+            XmlUtils.setNode(doc, HeritrixTemplate.DEDUPLICATOR_INDEX_LOCATION_XPATH, files.getIndexDir()
                     .getAbsolutePath());
         }
-        files.writeOrderXml(templ);
+
+        files.writeOrderXml(doc);
     }
-	
-    public abstract void setDeduplicationIndexLocation(String absolutePath);
-	public abstract void setSeedsFilePath(String absolutePath);
-
-    public abstract void setArchiveFilePrefix(String archiveFilePrefix);
-    public abstract void setDiskPath(String absolutePath);
-    
-	
-	public abstract void writeTemplate(OutputStream os) throws IOException, ArgumentNotValid;
-	
-	public abstract boolean hasContent();
-	
-	public abstract void writeToFile(File orderXmlFile);
-	public abstract void setRecoverlogNode(File recoverlogGzFile);
-	
-	/**
-     * Try to extract an orderxmldoc from a given Clob. This method is used by the read() method, which catches the
-     * thrown DocumentException.
-     *
-     * @param clob a given Clob returned from the database
-     * @return a Document object based on the data in the Clob
-     * @throws SQLException If data from the clob cannot be fetched.
-     * @throws DocumentException If unable to create a Document object based on the data in the Clob
-     */
-    public static HeritrixTemplate getOrderXMLdocFromClob(Clob clob) throws SQLException {
-    	// Taste the first 1000 characters, and look for the signatures of the different types of template.    	
-    	String signature = clob.getSubString(0L, 1000);
-    	if (signature.contains(HeritrixTemplate.H1_SIGNATURE)) {
-    		return new H1HeritrixTemplate(clob); 
-    	} else if (signature.contains(HeritrixTemplate.H3_SIGNATURE)) {
-    		return new H3HeritrixTemplate(clob);
-    	} else {
-    		throw new IllegalState("The template starting with '" + signature + "' cannot be recognized as either H1 or H3");
-    	}
-    }
-	/*
-	public static HeritrixTemplate read(String string) {
-		String signature = string.substring(0, 1000);
-		if (signature.contains(HeritrixTemplate.H1_SIGNATURE)) {
-    		return new H1HeritrixTemplate(string); 
-    	} else if (signature.contains(HeritrixTemplate.H3_SIGNATURE)) {
-    		return new H3HeritrixTemplate(string);
-    	} else {
-    		throw new IllegalState("The template starting with '" + signature + "' cannot be recognized as either H1 or H3");
-    	}
-	}
-	*/
-	public static HeritrixTemplate getTemplateFromString(String templateAsString) {
-		if (templateAsString.contains(H1_SIGNATURE)) {
-			return new H1HeritrixTemplate(templateAsString);
-		} else if (templateAsString.contains(H3_SIGNATURE)) {
-			return new H3HeritrixTemplate(templateAsString);
-		} else {
-			throw new ArgumentNotValid("The given template is neither H1 or H3: " + templateAsString);
-		}
-	}
-	
-	
-	
-	
-	/** 
-     * Read the
-     * @param orderXmlFile
-     * @return
-     */
-	public static HeritrixTemplate read(File orderXmlFile) {
-		return null;
-	}
-	
-	/**
-	 * 
-	 * @param orderTemplateReader
-	 * @return
-	 */
-	public static HeritrixTemplate read(Reader orderTemplateReader) {
-		return null;
-	}
-	
-	
-	/**
-	 * Try to remove the deduplicator, if present in the template.
-	 */
-	public abstract void removeDeduplicatorIfPresent();
-	
+
 }
diff -ur datamodel/JobDBDAO.java datamodel.newest/JobDBDAO.java
--- datamodel/JobDBDAO.java	2014-10-22 16:55:18.809291805 +0200
+++ datamodel.newest/JobDBDAO.java	2014-10-22 17:40:19.492110469 +0200
@@ -132,7 +132,7 @@
             statement.setLong(7, job.getMaxJobRunningTime());
             DBUtils.setStringMaxLength(statement, 8, job.getOrderXMLName(), Constants.MAX_NAME_SIZE, job,
                     "order.xml name");
-            final String orderreader = job.getOrderXMLdoc().getXML();
+            final String orderreader = job.getOrderXMLdoc().asXML();
             DBUtils.setClobMaxLength(statement, 9, orderreader, Constants.MAX_ORDERXML_SIZE, job, "order.xml");
             DBUtils.setClobMaxLength(statement, 10, job.getSeedListAsString(), Constants.MAX_COMBINED_SEED_LIST_SIZE,
                     job, "seedlist");
@@ -305,7 +305,7 @@
             statement.setLong(6, job.getMaxJobRunningTime());
             DBUtils.setStringMaxLength(statement, 7, job.getOrderXMLName(), Constants.MAX_NAME_SIZE, job,
                     "order.xml name");
-            final String orderreader = job.getOrderXMLdoc().getXML();
+            final String orderreader = job.getOrderXMLdoc().asXML();
             DBUtils.setClobMaxLength(statement, 8, orderreader, Constants.MAX_ORDERXML_SIZE, job, "order.xml");
             DBUtils.setClobMaxLength(statement, 9, job.getSeedListAsString(), Constants.MAX_COMBINED_SEED_LIST_SIZE,
                     job, "seedlist");
@@ -400,14 +400,14 @@
             long forceMaxRunningTime = result.getLong(6);
             String orderxml = result.getString(7);
 
-            HeritrixTemplate orderXMLdoc = null;
+            Document orderXMLdoc = null;
 
             boolean useClobs = DBSpecifics.getInstance().supportsClob();
             if (useClobs) {
                 Clob clob = result.getClob(8);
-                orderXMLdoc = HeritrixTemplate.getOrderXMLdocFromClob(clob);
+                orderXMLdoc = getOrderXMLdocFromClob(clob);
             } else {
-                orderXMLdoc = HeritrixTemplate.getTemplateFromString(result.getString(8));
+                orderXMLdoc = XmlUtils.documentFromString(result.getString(8));
             }
             String seedlist = "";
             if (useClobs) {
@@ -486,16 +486,40 @@
             } else {
                 job.setHarvestFilenamePrefix(harvestnamePrefix);
             }
+
             return job;
         } catch (SQLException e) {
             String message = "SQL error reading job " + jobID + " in database" + "\n"
                     + ExceptionUtils.getSQLExceptionCause(e);
             log.warn(message, e);
             throw new IOFailure(message, e);
+        } catch (DocumentException e) {
+            String message = "XML error reading job " + jobID + " in database";
+            log.warn(message, e);
+            throw new IOFailure(message, e);
         }
     }
 
-    
+    /**
+     * Try to extract an orderxmldoc from a given Clob. This method is used by the read() method, which catches the
+     * thrown DocumentException.
+     *
+     * @param clob a given Clob returned from the database
+     * @return a Document object based on the data in the Clob
+     * @throws SQLException If data from the clob cannot be fetched.
+     * @throws DocumentException If unable to create a Document object based on the data in the Clob
+     */
+    private Document getOrderXMLdocFromClob(Clob clob) throws SQLException, DocumentException {
+        Document doc;
+        try {
+            SAXReader reader = new SAXReader();
+            doc = reader.read(clob.getCharacterStream());
+        } catch (DocumentException e) {
+            log.warn("Failed to read the contents of the clob as XML:" + clob.getSubString(1, (int) clob.length()));
+            throw e;
+        }
+        return doc;
+    }
 
     /**
      * Return a list of all jobs with the given status, ordered by id.
@@ -776,7 +800,7 @@
                 + " WHERE currenthd.harvest_id=?" + " AND fullharvests.harvest_id" + "=harvestdefinitions.harvest_id"
                 + " AND harvestdefinitions.submitted<currenthd.submitted" + " ORDER BY harvestdefinitions.submitted "
                 + HarvestStatusQuery.SORT_ORDER.DESC.name(), firstHarvest);
-        // Follow the chain of originating IDs back
+        // Follow the chain of orginating IDs back
         // FIXME Rewrite this loop!
         for (Long originatingHarvest = olderHarvest; originatingHarvest != null; originatingHarvest = DBUtils
                 .selectFirstLongValueIfAny(connection,
diff -ur datamodel/Job.java datamodel.newest/Job.java
--- datamodel/Job.java	2014-10-22 17:16:59.127406228 +0200
+++ datamodel.newest/Job.java	2014-10-22 17:40:19.492110469 +0200
@@ -43,6 +43,7 @@
 import java.util.regex.Pattern;
 
 import org.apache.commons.io.IOUtils;
+import org.dom4j.Document;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -98,13 +99,12 @@
     /** The name of the harvest template used by the job. */
     private String orderXMLname;
     /** The harvest template used by the job. */
-    private HeritrixTemplate orderXMLdoc;
+    private Document orderXMLdoc;
     /** The list of Heritrix settings files. */
     private File[] settingsXMLfiles;
-    
     /** The corresponding Dom4j Documents for these files. */
-    //private Document[] settingsXMLdocs;
-   
+    private Document[] settingsXMLdocs;
+
     /**
      * A set of seeds involved in this job. Outside the SetSeedList() method, the set of seeds is updated in the
      * addConfiguration() method.
@@ -221,7 +221,7 @@
      * @param harvestNum the run number of the harvest definition
      * @throws ArgumentNotValid if cfg or priority is null or harvestID is invalid, or if any limit < -1
      */
-    public Job(Long harvestID, DomainConfiguration cfg, HarvestChannel channel,
+    public Job(Long harvestID, DomainConfiguration cfg, Document orderXMLdoc, HarvestChannel channel,
             long forceMaxObjectsPerDomain,
             long forceMaxBytesPerDomain, long forceMaxJobRunningTime, int harvestNum) throws ArgumentNotValid {
         ArgumentNotValid.checkNotNull(cfg, "cfg");
@@ -252,8 +252,7 @@
         domainConfigurationMap = new HashMap<>();
         origHarvestDefinitionID = harvestID;
         orderXMLname = cfg.getOrderXmlName();
-        orderXMLdoc = TemplateDAO.getInstance().read(cfg.getOrderXmlName());
-
+        this.orderXMLdoc = orderXMLdoc;
 
         setHarvestChannel(channel);
 
@@ -286,7 +285,7 @@
             log.debug(msg);
             throw new IllegalState(msg);
         }
-        orderXMLdoc.setArchiveFormat(archiveFormat);
+        HeritrixTemplate.editOrderXML_ArchiveFormat(orderXMLdoc, archiveFormat);
     }
 
     /**
@@ -308,7 +307,7 @@
      */
     Job(Long harvestID, Map<String, String> configurations, String channel, boolean snapshot,
             long forceMaxObjectsPerDomain, long forceMaxBytesPerDomain, long forceMaxJobRunningTime, JobStatus status,
-            String orderXMLname, HeritrixTemplate orderXMLdoc, String seedlist, int harvestNum, Long continuationOf) {
+            String orderXMLname, Document orderXMLdoc, String seedlist, int harvestNum, Long continuationOf) {
         origHarvestDefinitionID = harvestID;
         domainConfigurationMap = configurations;
         this.channel = channel;
@@ -326,56 +325,6 @@
     }
 
     /**
-<<<<<<< HEAD
-     * Create new Job configured according to the properties of the supplied DomainConfiguration.
-     *
-     * @param harvestID the id of the harvestdefinition
-     * @param channel the {@link HarvestChannel}
-     * @param cfg the configuration to base the Job on
-     * @param harvestNum Which run of the harvest definition this is.
-     * @return newly created Job.
-     * @throws ArgumentNotValid if cfg is null or harvestID is invalid
-     */
-    public static Job createJob(Long harvestID, HarvestChannel channel, DomainConfiguration cfg, int harvestNum) {
-        // Use -1 to indicate no limits for max objects and max bytes.
-        return new Job(harvestID, cfg, channel, Constants.HERITRIX_MAXOBJECTS_INFINITY,
-                Constants.HERITRIX_MAXBYTES_INFINITY, Constants.HERITRIX_MAXJOBRUNNINGTIME_INFINITY, harvestNum);
-    }
-
-    /**
-     * Create new instance of Job suitable for snapshot harvesting. This job is configured according to the properties
-     * of the supplied DomainConfiguration. The maximum number of objects retrieved from all domains added to this job
-     * is determined by maxObjectsPerDomain, regardless of the configuration settings, that are overridden.
-     *
-     * @param harvestID the id of the harvestdefinition
-     * @param channel the channel for the job
-     * @param cfg the configuration to base the Job on
-     * @param maxObjectsPerDomain the maximum number of objects to harvest from a domain, overrides individual
-     * configuration settings unless the domain has overrideLimits set. 0 means no limit.
-     * @param maxBytesPerDomain the maximum number of bytes to harvest from a domain, overrides individual configuration
-     * settings unless the domain has overrideLimits set. -1 means no limit.
-     * @param maxJobRunningTime The maximum of seconds which the harvest can spend on the harvest. 0 means no limit.
-     * @param harvestNum Which run of the harvest definition this is (should always be 1).
-     * @return SnapShotJob
-     * @throws ArgumentNotValid if cfg is null or harvestID is invalid
-     */
-    public static Job createSnapShotJob(Long harvestID, HarvestChannel channel, DomainConfiguration cfg,
-            long maxObjectsPerDomain, long maxBytesPerDomain, long maxJobRunningTime, int harvestNum)
-            throws ArgumentNotValid {
-        return new Job(harvestID, cfg, channel, maxObjectsPerDomain, maxBytesPerDomain, maxJobRunningTime, harvestNum);
-    }
-
-    /**
-     * Reads a list of all active global crawler trap expressions from the database and adds them to the crawl template
-     * for this job.
-     */
-    private void addGlobalCrawlerTraps(HeritrixTemplate orderXmlDoc) {
-        GlobalCrawlerTrapListDAO dao = GlobalCrawlerTrapListDAO.getInstance();
-        orderXmlDoc.insertCrawlerTraps(Constants.GLOBAL_CRAWLER_TRAPS_ELEMENT_NAME,
-                dao.getAllActiveTrapExpressions());
-    }
-
-    /**
      * Adds a configuration to this Job. Seedlists and settings are updated accordingly.
      *
      * @param cfg the configuration to add
@@ -449,7 +398,7 @@
             }
         }
 
-        orderXMLdoc.editOrderXMLAddPerDomainCrawlerTraps(cfg);
+        HeritrixTemplate.editOrderXMLAddPerDomainCrawlerTraps(orderXMLdoc, cfg);
 
         // TODO update limits in settings files - see also bug 269
 
@@ -592,7 +541,7 @@
      *
      * @param doc A orderxml to be used by this job
      */
-    public void setOrderXMLDoc(HeritrixTemplate doc) {
+    public void setOrderXMLDoc(Document doc) {
         ArgumentNotValid.checkNotNull(doc, "doc");
         this.orderXMLdoc = doc;
     }
@@ -602,18 +551,18 @@
      *
      * @return the XML as a org.dom4j.Document
      */
-    public HeritrixTemplate getOrderXMLdoc() {
+    public Document getOrderXMLdoc() {
         return orderXMLdoc;
     }
 
-//    /**
-//     * Gets a list of document representations of the settings.xml's associated with this Job.
-//     *
-//     * @return the XML as an array of org.dom4j.Document
-//     */
-//    public Document[] getSettingsXMLdocs() {
-//        return settingsXMLdocs;
-//    }
+    /**
+     * Gets a list of document representations of the settings.xml's associated with this Job.
+     *
+     * @return the XML as an array of org.dom4j.Document
+     */
+    public Document[] getSettingsXMLdocs() {
+        return settingsXMLdocs;
+    }
 
     /**
      * Set the seedlist of the job from the seedList argument. Individual seeds are separated by a '\n' character.
@@ -672,9 +621,9 @@
         }
 
         if ((this.status == JobStatus.NEW || this.status == JobStatus.RESUBMITTED) && newStatus == JobStatus.SUBMITTED) {
-            orderXMLdoc.configureQuotaEnforcer(maxObjectsIsSetByQuotaEnforcer, forceMaxBytesPerDomain, forceMaxObjectsPerDomain);
+            HeritrixTemplate.editOrderXML_configureQuotaEnforcer(orderXMLdoc, maxObjectsIsSetByQuotaEnforcer,
+                    forceMaxBytesPerDomain, forceMaxObjectsPerDomain);
         }
-            
 
         if (this.status == JobStatus.SUBMITTED && newStatus == JobStatus.STARTED) {
             setActualStart(new Date());
@@ -800,11 +749,9 @@
             log.debug(msg);
             throw new IllegalState(msg);
         }
-        
         this.forceMaxObjectsPerDomain = maxObjectsPerDomain;
-        orderXMLdoc.setMaxObjectsPerDomain(maxObjectsPerDomain); // FIXME? add argument to maxObjectsIsSetByQuotaEnforcer to method setMaxObjectsPerDomain  
-        //orderXMLdoc.editOrderXML_maxObjectsPerDomain(orderXMLdoc, maxObjectsPerDomain,
-        //        maxObjectsIsSetByQuotaEnforcer);
+        HeritrixTemplate.editOrderXML_maxObjectsPerDomain(orderXMLdoc, maxObjectsPerDomain,
+                maxObjectsIsSetByQuotaEnforcer);
 
         if (0L == maxObjectsPerDomain && 0L != forceMaxBytesPerDomain) {
             setMaxBytesPerDomain(0L);
@@ -823,8 +770,7 @@
             throw new IllegalState(msg);
         }
         this.forceMaxBytesPerDomain = maxBytesPerDomain;
-        orderXMLdoc.setMaxBytesPerDomain(maxBytesPerDomain);
-        //H1HeritrixTemplate.editOrderXML_maxBytesPerDomain(orderXMLdoc, maxBytesPerDomain);
+        HeritrixTemplate.editOrderXML_maxBytesPerDomain(orderXMLdoc, maxBytesPerDomain);
 
         if (0L == maxBytesPerDomain && 0L != forceMaxObjectsPerDomain) {
             setMaxObjectsPerDomain(0L);
@@ -843,7 +789,7 @@
             throw new IllegalState(msg);
         }
         this.forceMaxRunningTime = maxJobRunningTime;
-        orderXMLdoc.setMaxJobRunningTime(maxJobRunningTime);
+        HeritrixTemplate.editOrderXML_maxJobRunningTime(orderXMLdoc, maxJobRunningTime);
     }
 
     /**
@@ -1090,7 +1036,7 @@
         log.debug("The harvestPrefix of this job is: {}", prefix);
     }
 
-    /** @return the harvest-audience. */
+    /** @return the harvestaudience. */
     public String getHarvestAudience() {
         return harvestAudience;
     }
@@ -1098,7 +1044,7 @@
     /**
      * Set the harvest audience for this job. Taken from the harvestdefinition that generated this job.
      *
-     * @param theAudience the harvest-audience.
+     * @param theAudience the harvestaudience.
      */
     public void setHarvestAudience(String theAudience) {
         this.harvestAudience = theAudience;
diff -ur datamodel/TemplateDBDAO.java datamodel.newest/TemplateDBDAO.java
--- datamodel/TemplateDBDAO.java	2014-10-22 16:55:11.474275875 +0200
+++ datamodel.newest/TemplateDBDAO.java	2014-10-22 17:40:19.496110481 +0200
@@ -33,6 +33,9 @@
 import java.util.Iterator;
 import java.util.List;
 
+import org.dom4j.Document;
+import org.dom4j.DocumentException;
+import org.dom4j.io.SAXReader;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -91,21 +94,21 @@
                 String string = res.getString(1);
                 // log.debug("clob=" + string);
                 orderTemplateReader = new StringReader(string);
-            }            
-            return HeritrixTemplate.read(orderTemplateReader);
+            }
+            SAXReader reader = new SAXReader();
+            // TODO Check what happens on non-ascii
+            Document orderXMLdoc = reader.read(orderTemplateReader);
+            return new HeritrixTemplate(orderXMLdoc);
         } catch (SQLException e) {
             final String message = "SQL error finding order.xml for " + orderXmlName + "\n"
                     + ExceptionUtils.getSQLExceptionCause(e);
             log.warn(message, e);
             throw new IOFailure(message, e);
-       /*
         } catch (DocumentException e) {
             final String message = "Error parsing order.xml string for " + orderXmlName;
             log.warn(message, e);
             throw new IOFailure(message, e);
-            */
-        }
-         finally {
+        } finally {
             DBUtils.closeStatementIfOpen(s);
             HarvestDBConnection.release(c);
         }
